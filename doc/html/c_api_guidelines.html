<!--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  Copyright (c) 2016-2018 Qualcomm Technologies, Inc.
  All Rights Reserved.
  Confidential and Proprietary - Qualcomm Technologies, Inc.
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-->
<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"></meta>
<meta http-equiv="X-UA-Compatible" content="IE=9"></meta>
<title>Snapdragon Neural Processing Engine SDK: C API Guidelines</title>
<link href="tabs.css" rel="stylesheet" type="text/css"></link>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="autoEnterCurrentDate.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="is.css" rel="stylesheet" type="text/css" ></link>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Snapdragon Neural Processing Engine SDK
   <span id="projectnumber"></span></div>
   <div id="projectbrief">Reference Guide</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('c_api_guidelines.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">C API Guidelines </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The C API uses a handle based approach for accessing the SNPE API classes.</p>
<h1><a class="anchor" id="guidelines_handle_creation"></a>
Handle Creation</h1>
<p>The user can generate a handle for a specific class using the <b>Create</b> function call. The Create call is similar to creating an object in C++ by passing arguments to a constructor. In the below code excerpt, the Snpe_SNPEBuilder_Create function call creates a snpe builder object and returns back a handle, which can then be used by the user to invoke the builder object.</p>
<div class="fragment"><div class="line"><a class="code" href="group__c__apis.html#ga5525f7c887b922195624658ef8f12478">Snpe_SNPEBuilder_Handle_t</a> snpeBuilderHandle = <a class="code" href="group__c__apis.html#gabec895d2f45eb07b587b308c0c5c7cf3">Snpe_SNPEBuilder_Create</a>(containerHandle);</div></div><!-- fragment --><h1><a class="anchor" id="guidelines_handle_deletion"></a>
Handle Deletion</h1>
<p>The lifecycle of handles created and returned to the user needs to be managed by the user. i.e Every handle created by the user/ returned to the user by value needs to be deleted explicitly by the user. The following code excerpt, shows how the <b>Delete</b> call can be invoked by the user</p>
<div class="fragment"><div class="line"><a class="code" href="group__c__apis.html#ga3a160bced295466d70289dcf1deeffbf">Snpe_IUserBuffer_Handle_t</a> userBufferEncodingFloatHandle = <a class="code" href="group__c__apis.html#ga45eb9da0c7b281124c5909343c24ae9a">Snpe_UserBufferEncodingFloat_Create</a>();</div><div class="line"></div><div class="line"><a class="code" href="group__c__apis.html#gacfaf98af4f23052084f4493fa736ca28">Snpe_UserBufferEncodingFloat_Delete</a>(userBufferEncodingFloatHandle);</div></div><!-- fragment --><h1><a class="anchor" id="guidelines_handle_types"></a>
Types of handles</h1>
<p>There are three types of handles in the C API: </p><ol>
<li>
<b>Handle Created by User:</b> The User can invoke the <b>Create</b> method to generate a handle to access the object for a specific class. The handles generated using the create call needs to be deleted explicitly by the user by calling the corresponding <b>Delete</b> API call. <div class="fragment"><div class="line"><a class="code" href="group__c__apis.html#gaf5de4fb49e732ad0d0ffc094b6d8d94e">Snpe_RuntimeList_Handle_t</a> runtimeListHandle = <a class="code" href="group__c__apis.html#gae03c0633ecd9aada6fa34a7ff7e9884d">Snpe_RuntimeList_Create</a>();</div><div class="line"></div><div class="line"><a class="code" href="group__c__apis.html#ga67ee683c8adb37300ca57de3ec5b4b6c">Snpe_RuntimeList_Delete</a>(runtimeListHandle);</div></div><!-- fragment --> </li>
<li>
<b>Handle returned by Value:</b> When an API returns back a handle of a different type, the lifecycle of the handle is to be managed by the user. The following excerpt demonstrates the return by value scenario. <div class="fragment"><div class="line"><a class="code" href="group__c__apis.html#ga86a9e0d044299b1ed6b8a85280830503">Snpe_StringList_Handle_t</a> sl = <a class="code" href="group__c__apis.html#ga6602910d94b918aa2c05385d454a79e8">Snpe_UserBufferMap_GetUserBufferNames</a>(ubMapHandle);</div><div class="line"></div><div class="line"><a class="code" href="group__c__apis.html#ga88b38a24a1d114b1a6e12b076ecf7a82">Snpe_StringList_Delete</a>(sl);</div></div><!-- fragment --> </li>
<li>
<b>Handle returned by Reference:</b> When a handle is returned by an API as reference. The handle is implicitly deleted when the parent handle is deleted. So the user does not have to manage the lifecycle in this case. The API returning a handle by ref is denoted by <b>_Ref</b>. In the following code excerpt the ubHandle is deleted when the Delete API is called on the ubMapHandle. <div class="fragment"><div class="line"><a class="code" href="group__c__apis.html#ga3a160bced295466d70289dcf1deeffbf">Snpe_IUserBuffer_Handle_t</a> ubHandle = <a class="code" href="group__c__apis.html#gae218294c1c510dbffd962f4d4fe14412">Snpe_UserBufferMap_GetUserBuffer_Ref</a>(ubMapHandle, name);</div><div class="line"></div><div class="line"><a class="code" href="group__c__apis.html#ga72e3193af0c3fc058ac77c1a64c57dee">Snpe_UserBufferMap_Delete</a>(ubMapHandle);</div></div><!-- fragment --> </li>
</ol>
<h1><a class="anchor" id="guidelines_porting"></a>
Porting C++ APIs to C</h1>
<p>The C API functions follow the pattern "Snpe_&lt;ClassName&gt;_&lt;function&gt;(&lt;objectHandle&gt;, ...)". As the C API uses a handle based approach, while translating the C++ APIs, the handle to access the object needs to be passed as an argument. The following code snippets demonstrates the translation of C++ SNPE API to C API.</p>
<p>C++ API calls to create a userbuffer Map: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> createUserBuffer(<a class="code" href="group__c__plus__plus__apis.html#classzdl_1_1DlSystem_1_1UserBufferMap">zdl::DlSystem::UserBufferMap</a>&amp; userBufferMap,</div><div class="line">                      std::unordered_map&lt;std::string, std::vector&lt;uint8_t&gt;&gt;&amp; applicationBuffers,</div><div class="line">                      std::vector&lt;std::unique_ptr&lt;zdl::DlSystem::IUserBuffer&gt;&gt;&amp; snpeUserBackedBuffers,</div><div class="line">                      std::unique_ptr&lt;zdl::SNPE::SNPE&gt;&amp; snpe,</div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">char</span> * name)</div><div class="line">{</div><div class="line">   <span class="comment">// get attributes of buffer by name</span></div><div class="line">   <span class="keyword">auto</span> bufferAttributesOpt = snpe-&gt;getInputOutputBufferAttributes(name);</div><div class="line">   <span class="keywordflow">if</span> (!bufferAttributesOpt) <span class="keywordflow">throw</span> std::runtime_error(std::string(<span class="stringliteral">&quot;Error obtaining attributes for input tensor &quot;</span>) + name);</div><div class="line"></div><div class="line">   <span class="comment">// calculate the size of buffer required by the input tensor</span></div><div class="line">   <span class="keyword">const</span> <a class="code" href="group__c__plus__plus__apis.html#classzdl_1_1DlSystem_1_1TensorShape">zdl::DlSystem::TensorShape</a>&amp; bufferShape = (*bufferAttributesOpt)-&gt;getDims();</div><div class="line"></div><div class="line">   <span class="comment">// Calculate the stride based on buffer strides, assuming tightly packed.</span></div><div class="line">   <span class="comment">// Note: Strides = Number of bytes to advance to the next element in each dimension.</span></div><div class="line">   <span class="comment">// For example, if a float tensor of dimension 2x4x3 is tightly packed in a buffer of 96 bytes, then the strides would be (48,12,4)</span></div><div class="line">   <span class="comment">// Note: Buffer stride is usually known and does not need to be calculated.</span></div><div class="line">   std::vector&lt;size_t&gt; strides(bufferShape.<a class="code" href="group__c__plus__plus__apis.html#ga0733c94f87784147f398499c1bd7c713">rank</a>());</div><div class="line">   strides[strides.size() - 1] = <span class="keyword">sizeof</span>(float);</div><div class="line">   <span class="keywordtype">size_t</span> stride = strides[strides.size() - 1];</div><div class="line">   <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = bufferShape.<a class="code" href="group__c__plus__plus__apis.html#ga0733c94f87784147f398499c1bd7c713">rank</a>() - 1; i &gt; 0; i--)</div><div class="line">   {</div><div class="line">      stride *= bufferShape[i];</div><div class="line">      strides[i-1] = stride;</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="keyword">const</span> <span class="keywordtype">size_t</span> bufferElementSize = (*bufferAttributesOpt)-&gt;getElementSize();</div><div class="line">   <span class="keywordtype">size_t</span> bufSize = calcSizeFromDims(bufferShape.<a class="code" href="group__c__plus__plus__apis.html#ga352b3640f2e99867c092a1b260203a13">getDimensions</a>(), bufferShape.<a class="code" href="group__c__plus__plus__apis.html#ga0733c94f87784147f398499c1bd7c713">rank</a>(), bufferElementSize);</div><div class="line"></div><div class="line">   <span class="comment">// set the buffer encoding type</span></div><div class="line">   <a class="code" href="group__c__plus__plus__apis.html#classzdl_1_1DlSystem_1_1UserBufferEncodingFloat">zdl::DlSystem::UserBufferEncodingFloat</a> userBufferEncodingFloat;</div><div class="line"></div><div class="line">   <span class="comment">// create user-backed storage to load input data onto it</span></div><div class="line">   applicationBuffers.emplace(name, std::vector&lt;uint8_t&gt;(bufSize));</div><div class="line"></div><div class="line">   <span class="comment">// create SNPE user buffer from the user-backed buffer</span></div><div class="line">   <a class="code" href="group__c__plus__plus__apis.html#classzdl_1_1DlSystem_1_1IUserBufferFactory">zdl::DlSystem::IUserBufferFactory</a>&amp; ubFactory = <a class="code" href="group__c__plus__plus__apis.html#ab32e0a7ce9242415177a00510f0978f1">zdl::SNPE::SNPEFactory::getUserBufferFactory</a>();</div><div class="line">   snpeUserBackedBuffers.push_back(ubFactory.<a class="code" href="group__c__plus__plus__apis.html#a58980a08c317c8dcb7943821e60f9cb8">createUserBuffer</a>(applicationBuffers.at(name).data(),</div><div class="line">                                                              bufSize,</div><div class="line">                                                              strides,</div><div class="line">                                                              &amp;userBufferEncodingFloat));</div><div class="line"></div><div class="line">   <span class="comment">// add the user-backed buffer to the inputMap, which is later on fed to the network for execution</span></div><div class="line">   userBufferMap.<a class="code" href="group__c__plus__plus__apis.html#a3deb982f909567eed3b86bead18a222e">add</a>(name, snpeUserBackedBuffers.back().get());</div></div><!-- fragment --><p>C API calls to create a userbuffer Map: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> createUserBuffer(<a class="code" href="group__c__apis.html#ga2989cd43b0d4716b6c313ee6cbbd349e">Snpe_UserBufferMap_Handle_t</a> userBufferMapHandle,</div><div class="line">                      std::unordered_map&lt;std::string, std::vector&lt;uint8_t&gt;&gt;&amp; applicationBuffers,</div><div class="line">                      std::vector&lt;Snpe_IUserBuffer_Handle_t&gt; snpeUserBackedBuffersHandle,</div><div class="line">                      <a class="code" href="group__c__apis.html#gac4d946a1db4097746e726714e145e08a">Snpe_SNPE_Handle_t</a> snpeHandle,</div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">char</span> * name)</div><div class="line">{</div><div class="line">   <span class="comment">// get attributes of buffer by name</span></div><div class="line">   <a class="code" href="group__c__apis.html#ga5339ab1d422c3bf2213bbbd856b093de">Snpe_IBufferAttributes_Handle_t</a> bufferAttributesOptHandle = <a class="code" href="group__c__apis.html#gab83a768709354404ff6d97013b48253e">Snpe_SNPE_GetInputOutputBufferAttributes</a>(snpeHandle, name);</div><div class="line">   <span class="keywordflow">if</span> (bufferAttributesOptHandle == <span class="keyword">nullptr</span>) <span class="keywordflow">throw</span> std::runtime_error(std::string(<span class="stringliteral">&quot;Error obtaining attributes for input tensor &quot;</span>) + name);</div><div class="line"></div><div class="line">   <span class="comment">// calculate the size of buffer required by the input tensor</span></div><div class="line">   <a class="code" href="group__c__apis.html#gaa2c4ee3ae82899680c05757c4c44c1ee">Snpe_TensorShape_Handle_t</a> bufferShapeHandle = <a class="code" href="group__c__apis.html#ga9a2bd09838a81ab3c8b97873d8b1472e">Snpe_IBufferAttributes_GetDims</a>(bufferAttributesOptHandle);</div><div class="line"></div><div class="line">   <span class="comment">// Calculate the stride based on buffer strides, assuming tightly packed.</span></div><div class="line">   <span class="comment">// Note: Strides = Number of bytes to advance to the next element in each dimension.</span></div><div class="line">   <span class="comment">// For example, if a float tensor of dimension 2x4x3 is tightly packed in a buffer of 96 bytes, then the strides would be (48,12,4)</span></div><div class="line">   <span class="comment">// Note: Buffer stride is usually known and does not need to be calculated.</span></div><div class="line">   std::vector&lt;size_t&gt; strides(<a class="code" href="group__c__apis.html#gaa7e9a86ec9e42b5ef78e62e80596ac5e">Snpe_TensorShape_Rank</a>(bufferShapeHandle));</div><div class="line">   strides[strides.size() - 1] = <span class="keyword">sizeof</span>(float);</div><div class="line">   <span class="keywordtype">size_t</span> stride = strides[strides.size() - 1];</div><div class="line">   <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = <a class="code" href="group__c__apis.html#gaa7e9a86ec9e42b5ef78e62e80596ac5e">Snpe_TensorShape_Rank</a>(bufferShapeHandle) - 1; i &gt; 0; i--)</div><div class="line">   {</div><div class="line">      stride *= <a class="code" href="group__c__apis.html#gadd0bc813a6944ea9bf0edb95f7ebb590">Snpe_TensorShape_At</a>(bufferShapeHandle, i);</div><div class="line">      strides[i-1] = stride;</div><div class="line">   }</div><div class="line">   <a class="code" href="group__c__apis.html#gaa2c4ee3ae82899680c05757c4c44c1ee">Snpe_TensorShape_Handle_t</a> stridesHandle = <a class="code" href="group__c__apis.html#ga9795e5b62042261d0fb19bac43e6b191">Snpe_TensorShape_CreateDimsSize</a>(strides.data(), <a class="code" href="group__c__apis.html#gaa7e9a86ec9e42b5ef78e62e80596ac5e">Snpe_TensorShape_Rank</a>(bufferShapeHandle));</div><div class="line"></div><div class="line">   <span class="keywordtype">size_t</span> bufferElementSize = <a class="code" href="group__c__apis.html#ga2357d68f541395982d4f41d736333faf">Snpe_IBufferAttributes_GetElementSize</a>(bufferAttributesOptHandle);</div><div class="line">   <span class="keywordtype">size_t</span> bufSize = calcSizeFromDims(<a class="code" href="group__c__apis.html#gadfab44b53e35a57c920c495149230f24">Snpe_TensorShape_GetDimensions</a>(bufferShapeHandle), <a class="code" href="group__c__apis.html#gaa7e9a86ec9e42b5ef78e62e80596ac5e">Snpe_TensorShape_Rank</a>(bufferShapeHandle), bufferElementSize);</div><div class="line"></div><div class="line">   <span class="comment">// set the buffer encoding type</span></div><div class="line">   <a class="code" href="group__c__apis.html#gaf8d0448ead613b976948e31bc968f66b">Snpe_UserBufferEncoding_Handle_t</a> userBufferEncodingFloatHandle = <a class="code" href="group__c__apis.html#ga45eb9da0c7b281124c5909343c24ae9a">Snpe_UserBufferEncodingFloat_Create</a>();</div><div class="line"></div><div class="line">   <span class="comment">// create user-backed storage to load input data onto it</span></div><div class="line">   applicationBuffers.emplace(name, std::vector&lt;uint8_t&gt;(bufSize));</div><div class="line"></div><div class="line">   <span class="comment">// create SNPE user buffer from the user-backed buffer</span></div><div class="line">   ubsHandle.push_back(<a class="code" href="group__c__apis.html#gab09f89ba1573bcb8ed540dd14b846aff">Snpe_Util_CreateUserBuffer</a>(applicationBuffers.at(name).data(),</div><div class="line">                                                  bufSize,</div><div class="line">                                                  stridesHandle,</div><div class="line">                                                  userBufferEncodingFloatHandle));</div><div class="line"></div><div class="line">   <span class="comment">// add the user-backed buffer to the inputMap, which is later on fed to the network for execution</span></div><div class="line">   <a class="code" href="group__c__apis.html#gae0b60cbf32986d7947f549e63f87a4e6">Snpe_UserBufferMap_Add</a>(userBufferMapHandle, name, snpeUserBackedBuffersHandle.back());</div><div class="line"></div><div class="line">   <span class="comment">// clean up created handles</span></div><div class="line">   <a class="code" href="group__c__apis.html#gad22461d7fcf5672b1f3620063f8e9923">Snpe_IBufferAttributes_Delete</a>(bufferAttributesOptHandle);</div><div class="line">   <a class="code" href="group__c__apis.html#gacfaf98af4f23052084f4493fa736ca28">Snpe_UserBufferEncodingFloat_Delete</a>(userBufferEncodingFloatHandle);</div><div class="line">   <a class="code" href="group__c__apis.html#ga39bfc40f79e43e561f8793f0d2cea365">Snpe_TensorShape_Delete</a>(bufferShapeHandle);</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!--%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  Copyright (c) 2016-2018 Qualcomm Technologies, Inc.
  All Rights Reserved.
  Confidential and Proprietary - Qualcomm Technologies, Inc.
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 -->
<!-- start footer part -->
<div id="nav-path" class="navpath" font-size:small;><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
      <p align="right">
        80-NL315-14 A <br>
        MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION
        <!--If the Controlled Distribution statement is to be included, uncomment below:-->
        <!--<b>Controlled Distribution - DO NOT COPY</b>-->
        <img class="footer" width:5%; alt="QTI Logo" src="images/QTI_Logo.png" />
      </p>
    </li>
  </ul>
</div>
</body>
</html>
